#  Copyright © 1997—1999 Thomas Boutell <boutell@boutell.com>
#                        and Boutell.Com, Inc.
#            © 2003—2021 Sam Hocevar <sam@hocevar.net>
#            © 2026 Marcin Gryszkalis <mg@fork.pl>
#
#  This software is released for free use under the terms of
#  the GNU Public License, version 2 or higher. NO WARRANTY
#  IS EXPRESSED OR IMPLIED. USE THIS SOFTWARE AT YOUR OWN RISK. */

%{
#if HAVE_CONFIG_H
#   include <config.h>
#endif

#include "net.h"
#include "types.h"
#include "rinetd.h"
#include "parse.h"

#include <glob.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#define YY_CTX_LOCAL 1
#define YY_CTX_MEMBERS \
    FILE *fp; \
    int currentLine; \
    int isAuthAllow; \
    char *tmpPort, *bindPort, *connectPort; \
    int tmpProto, bindProto, connectProto; \
    int serverTimeout; \
    int keepalive; \
    int dns_refresh_period; \
    char *bindAddress, *connectAddress, *sourceAddress; \
    /* Include tracking */ \
    int includeDepth; \
    char **includedFiles; \
    int includedFilesCount; \
    int includedFilesCapacity; \
    char *currentFile;
#define YY_INPUT(yyctx, buf, result, max_size) \
{ \
    int yyc = fgetc(yyctx->fp); \
    result = (EOF == yyc) ? 0 : (*(buf) = yyc, 1); \
}
#define PARSE_ERROR exit(1);
#define MEMORY_ERROR { \
        logError("could not allocate memory when parsing configuration.\n"); \
        exit(1); \
    }

#if defined __clang__
#pragma clang diagnostic ignored "-Wunused-parameter"
#pragma clang diagnostic ignored "-Wunused-label"
#elif defined __GNUC__
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wunused-label"
#endif

/* Forward declarations for functions called from grammar actions */
struct _yycontext; /* Forward declaration - yycontext typedef defined later */
void parseConfigurationFile(char const *file, struct _yycontext *ctx);
void parseInclude(char const *pattern, struct _yycontext *ctx);

%}

file     =  (sol (line eol | invalid-syntax))*
line     =  -? (command -?)? comment?
command  =  (server-rule | auth-rule | logfile | pidfile | logcommon | buffersize | dns-refresh-global | include-directive)
comment  =  "#" (!eol .)*

server-rule  =  bind-address - bind-port - connect-address - connect-port (-? server-options)?
{
    /* keepalive: -1 = not set (default to on), 0 = off, 1 = on */
    int keepalive = (yy->keepalive == -1) ? 1 : yy->keepalive;

    /* dns_refresh_period: -1 = not set (use global default), >= 0 = explicit value */
    int dns_refresh = (yy->dns_refresh_period == -1)
                      ? globalDnsRefreshPeriod
                      : yy->dns_refresh_period;

    addServer(yy->bindAddress, yy->bindPort, yy->bindProto,
        yy->connectAddress, yy->connectPort, yy->connectProto,
        yy->serverTimeout > 0 ? yy->serverTimeout : RINETD_DEFAULT_UDP_TIMEOUT,
        yy->sourceAddress,
        keepalive, dns_refresh);
    free(yy->bindAddress);
    free(yy->connectAddress);
    free(yy->sourceAddress);
    yy->bindAddress = yy->connectAddress = yy->sourceAddress = NULL;
    free(yy->bindPort);
    free(yy->connectPort);
    yy->bindPort = yy->connectPort = NULL;
    yy->serverTimeout = 0;
    yy->keepalive = -1;
    yy->dns_refresh_period = -1;
}

bind-address     =  < address > { yy->bindAddress = strdup(yytext); }
connect-address  =  < address > { yy->connectAddress = strdup(yytext); }
bind-port        =  full-port { yy->bindPort = yy->tmpPort; yy->bindProto = yy->tmpProto; }
connect-port     =  full-port { yy->connectPort = yy->tmpPort; yy->connectProto = yy->tmpProto; }
server-options   =  "[" -? option-list -? "]"

option-list       =  option (-? ',' -? option-list)?
option            =  (option-timeout | option-source | option-keepalive | option-dns-refresh)
option-timeout    =  "timeout"    -? "=" -? < number >    { yy->serverTimeout = atoi(yytext); }
option-source     =  "src"        -? "=" -? < address >   { yy->sourceAddress = strdup(yytext); }
option-keepalive  =  "keepalive"  -? "=" -? < keepalive_value >  { yy->keepalive = (yytext[1] == 'n') ? 1 : 0; }
option-dns-refresh =  "dns-refresh" -? "=" -? < number >  { yy->dns_refresh_period = atoi(yytext); }

keepalive_value   =  "on" | "off"

full-port  =  port proto

port   = < (number | service) >   { yy->tmpPort = strdup(yytext); }
proto  = '/tcp'                   { yy->tmpProto = IPPROTO_TCP; }
       | '/udp'                   { yy->tmpProto = IPPROTO_UDP; }
       | ''                       { yy->tmpProto = IPPROTO_TCP; }

auth-rule  =  auth-key - < pattern >
{
    allRules = (Rule *)
        realloc(allRules, sizeof(Rule) * (allRulesCount + 1));
    if (!allRules) {
        MEMORY_ERROR;
    }
    allRules[allRulesCount].pattern = strdup(yytext);
    if (!allRules[allRulesCount].pattern) {
        MEMORY_ERROR;
    }
    allRules[allRulesCount].type = yy->isAuthAllow ? allowRule : denyRule;
    if (seTotal > 0) {
        if (seInfo[seTotal - 1].rulesStart == 0 && seInfo[seTotal - 1].rulesCount == 0) {
            seInfo[seTotal - 1].rulesStart = allRulesCount;
        }
        ++seInfo[seTotal - 1].rulesCount;
    } else {
        ++globalRulesCount;
    }
    ++allRulesCount;
}

auth-key = < ("allow" | "deny") >         { yy->isAuthAllow = (yytext[0] == 'a'); }

logfile  =  "logfile" - < filename >
{
    logFileName = strdup(yytext);
    if (!logFileName) {
        MEMORY_ERROR;
    }
}

pidfile  =  "pidfile" - < filename >
{
    pidLogFileName = strdup(yytext);
    if (!pidLogFileName) {
        MEMORY_ERROR;
    }
}

logcommon  =  "logcommon"
{
    logFormatCommon = 1;
}

buffersize  =  "buffersize" - < number >
{
    bufferSize = atoi(yytext);
    if (bufferSize < 1024 || bufferSize > 1048576) {
        logError("invalid buffer size %d at line %d (must be 1024-1048576)\n",
                 bufferSize, yy->currentLine);
        PARSE_ERROR;
    }
}

dns-refresh-global  =  "dns-refresh" - < number >
{
    globalDnsRefreshPeriod = atoi(yytext);
    if (globalDnsRefreshPeriod < 0) {
        logError("invalid dns-refresh value at line %d\n", yy->currentLine);
        PARSE_ERROR;
    }
}

include-directive  =  "include" - < filename >
{
    parseInclude(yytext, yy);
}

invalid_syntax  =  < (!eol .)+ > eol
{
    logError("invalid syntax at line %d: %s\n",
            yy->currentLine, yytext);
    PARSE_ERROR; /* FIXME */
}

service  =  name
address  =  ipv4 | ipv6 | hostname
pattern  =  (hexdigit | '[' | ']' | ':' | '.' | [*?] )+
number   =  digit+

ipv4      =  number '.' number '.' number '.' number | '0'
ipv6      = '[' bare_ipv6 ']' | bare_ipv6
bare_ipv6 =  hexdigit* ':' (hexdigit | ':')* # Must have at least one ':'
hostname  =  (label '.')* name '.'?


name     =  id ('-' | id | digit)*
label    =  (id | digit) ('-' | id | digit)* # DNS labels may have digits
filename =  '"' [^"]+ '"'
         |  [^ \t\r\n]+

-        =  [ \t]+
digit    =  [0-9]
hexdigit =  [0-9a-fA-F]
id       =  [a-zA-Z_]
sol      =  { ++yy->currentLine; }
eol      =  '\r'? '\n' | eof
eof      =  '\0'

%%

/* Utility functions for include directive support */

/* Check if file already included (circular detection) */
static int isFileIncluded(yycontext *ctx, char const *canonical_path)
{
    for (int i = 0; i < ctx->includedFilesCount; i++) {
        if (strcmp(ctx->includedFiles[i], canonical_path) == 0) {
            return 1;
        }
    }
    return 0;
}

/* Add file to included list */
static void addIncludedFile(yycontext *ctx, char const *canonical_path)
{
    /* Grow array if needed */
    if (ctx->includedFilesCount >= ctx->includedFilesCapacity) {
        int new_capacity = ctx->includedFilesCapacity == 0 ? 16 : ctx->includedFilesCapacity * 2;
        char **new_array = realloc(ctx->includedFiles, new_capacity * sizeof(char*));
        if (!new_array) {
            MEMORY_ERROR;
        }
        ctx->includedFiles = new_array;
        ctx->includedFilesCapacity = new_capacity;
    }

    /* Add to list */
    ctx->includedFiles[ctx->includedFilesCount++] = strdup(canonical_path);
}

/* Strip quotes from filename */
static char *stripQuotes(char const *str)
{
    size_t len = strlen(str);
    if (len >= 2 && str[0] == '"' && str[len-1] == '"') {
        char *result = malloc(len - 1);
        if (!result) MEMORY_ERROR;
        memcpy(result, str + 1, len - 2);
        result[len - 2] = '\0';
        return result;
    }
    return strdup(str);
}

/* Resolve relative paths based on current file's directory */
static char *resolveIncludePath(char const *pattern, char const *current_file)
{
    /* If absolute path, return as-is */
    if (pattern[0] == '/') {
        return strdup(pattern);
    }

    /* Extract directory from current_file */
    char *dir = strdup(current_file);
    char *last_slash = strrchr(dir, '/');
    if (last_slash) {
        *last_slash = '\0';
    } else {
        /* Current file has no directory component, use current working directory */
        free(dir);
        return strdup(pattern);
    }

    /* Construct absolute path: dir/pattern */
    size_t len = strlen(dir) + strlen(pattern) + 2;
    char *result = malloc(len);
    if (!result) MEMORY_ERROR;
    snprintf(result, len, "%s/%s", dir, pattern);
    free(dir);
    return result;
}

/* Free included files list */
static void freeIncludedFiles(yycontext *ctx)
{
    for (int i = 0; i < ctx->includedFilesCount; i++) {
        free(ctx->includedFiles[i]);
    }
    free(ctx->includedFiles);
    ctx->includedFiles = NULL;
    ctx->includedFilesCount = 0;
    ctx->includedFilesCapacity = 0;
}

/* Handle include directive - expand pattern and parse matched files */
void parseInclude(char const *pattern, yycontext *ctx)
{
    /* 1. Check recursion depth */
    if (ctx->includeDepth >= MAX_INCLUDE_DEPTH) {
        logError("maximum include depth (%d) exceeded at %s:%d\n",
                 MAX_INCLUDE_DEPTH, ctx->currentFile, ctx->currentLine);
        PARSE_ERROR;
    }

    /* 2. Strip quotes from pattern if present */
    char *unquoted_pattern = stripQuotes(pattern);

    /* 3. Convert to absolute path if relative */
    char *abs_pattern = resolveIncludePath(unquoted_pattern, ctx->currentFile);

    /* 4. Expand glob pattern */
    glob_t glob_result;
    int glob_flags = GLOB_TILDE | GLOB_BRACE;
    int ret = glob(abs_pattern, glob_flags, NULL, &glob_result);

    if (ret == GLOB_NOMATCH) {
        /* No files match - just log warning and continue */
        logInfo("warning: include pattern matches no files: %s at %s:%d\n",
                pattern, ctx->currentFile, ctx->currentLine);
        free(abs_pattern);
        free(unquoted_pattern);
        return;
    } else if (ret != 0) {
        logError("error expanding include pattern: %s at %s:%d\n",
                 pattern, ctx->currentFile, ctx->currentLine);
        free(abs_pattern);
        free(unquoted_pattern);
        PARSE_ERROR;
    }

    /* 5. Process each matched file */
    for (size_t i = 0; i < glob_result.gl_pathc; i++) {
        char *file = glob_result.gl_pathv[i];

        /* Skip directories */
        struct stat st;
        if (stat(file, &st) != 0) {
            logError("cannot stat include file: %s at %s:%d\n",
                     file, ctx->currentFile, ctx->currentLine);
            globfree(&glob_result);
            free(abs_pattern);
            free(unquoted_pattern);
            PARSE_ERROR;
        }

        if (S_ISDIR(st.st_mode)) {
            continue;  /* Skip directories silently */
        }

        /* Check for circular includes */
        char *canonical = realpath(file, NULL);
        if (!canonical) {
            logError("cannot resolve include file: %s at %s:%d\n",
                     file, ctx->currentFile, ctx->currentLine);
            globfree(&glob_result);
            free(abs_pattern);
            free(unquoted_pattern);
            PARSE_ERROR;
        }

        if (isFileIncluded(ctx, canonical)) {
            logError("circular include detected: %s at %s:%d\n",
                     file, ctx->currentFile, ctx->currentLine);
            free(canonical);
            globfree(&glob_result);
            free(abs_pattern);
            free(unquoted_pattern);
            PARSE_ERROR;
        }

        /* Add to included files list */
        addIncludedFile(ctx, canonical);

        /* Parse the included file */
        parseConfigurationFile(file, ctx);

        free(canonical);
    }

    globfree(&glob_result);
    free(abs_pattern);
    free(unquoted_pattern);
}

/* Internal function for parsing a single config file (supports recursion) */
void parseConfigurationFile(char const *file, yycontext *ctx)
{
    FILE *in = fopen(file, "r");
    if (!in) {
        logError("could not open configuration file %s at %s:%d\n",
                 file, ctx->currentFile, ctx->currentLine);
        exit(1);
    }

    /* Save current state */
    FILE *saved_fp = ctx->fp;
    int saved_line = ctx->currentLine;
    char *saved_file = ctx->currentFile;

    /* Set new state */
    ctx->fp = in;
    ctx->currentLine = 0;  /* Will be incremented by sol rule */
    ctx->currentFile = strdup(file);
    ctx->includeDepth++;

    /* Parse the file */
    if (!yyparse(ctx)) {
        logError("invalid syntax in file %s, line %d.\n",
                 ctx->currentFile, ctx->currentLine);
        exit(1);
    }

    /* Restore state */
    fclose(in);
    free(ctx->currentFile);
    ctx->currentFile = saved_file;
    ctx->currentLine = saved_line;
    ctx->fp = saved_fp;
    ctx->includeDepth--;
}

/* Main entry point for configuration parsing */
void parseConfiguration(char const *file)
{
    yycontext ctx;
    memset(&ctx, 0, sizeof(yycontext));
    ctx.keepalive = -1;
    ctx.dns_refresh_period = -1;

    /* Initialize include tracking */
    ctx.includeDepth = 0;
    ctx.includedFiles = NULL;
    ctx.includedFilesCount = 0;
    ctx.includedFilesCapacity = 0;
    ctx.currentFile = strdup(file);

    /* Add main config file to included list to prevent self-inclusion */
    char *canonical = realpath(file, NULL);
    if (canonical) {
        addIncludedFile(&ctx, canonical);
        free(canonical);
    }

    /* Parse main file */
    parseConfigurationFile(file, &ctx);

    /* Cleanup */
    free(ctx.currentFile);
    freeIncludedFiles(&ctx);
    yyrelease(&ctx);

    /* Avoid warnings for these unused functions */
    (void)yySet; (void)yyPush; (void)yyPop; (void)yyAccept;
}

